# -*- coding: utf-8 -*-
"""Final Project ID/X Partners.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s2DQb9yETkJXKslEwHOTslgYjePwVUjD

**Nama : Greiva Viandra Zahrani**

**Email : greivavndr@gmail.com**

# **Import Library (Basic)**
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings('ignore')

"""# **Read Dataset**"""

# Import Library
import pandas as pd

df = pd.read_csv('/content/loan_data_2007_2014.csv', index_col = 0)
df

"""Data yang digunakan memiliki 74 kolom dengan 466285 baris.

Berikut adalah nama semua kolom yang terdapat pada data:
"""

df.columns

"""# **Data Preparation**

## **Feature Selection**

Pada proses ini akan dilakukan seleksi data dengan mengambil kolom-kolom yang relevan dengan analisis ke depan.

Pada data loan, terdapat 74 kolom dengan keterangan setiap kolom sebagai berikut:

- 'id' : nomor id setiap pinjaman
- 'member_id' : nomor id setiap peminjam
- 'loan_amnt' : jumlah pinjaman yang diajukan oleh peminjam
- 'funded_amnt' : jumlah pinjaman yang diberikan kepada peminjam
- 'funded_amnt_inv' : jumlah pinjaman yang diberikan kepada peminjam setelah dikurangi biaya pengelolaan
- 'term' : jangka waktu pinjaman (dalam bulan)
- 'int_rate' : suku bunga pinjaman (dalam persen)
- 'installment' : jumlah pembayaran bulanan yang harus dibayarkan oleh peminjam
- 'grade' : tingkat risiko pinjaman (dari A hingga G)
- 'sub_grade' : tingkat risiko pinjaman lebih rinci (dari 1 hingga 5)
- 'emp_title' : nama pekerjaan peminjam
- 'emp_length' : lama kerja peminjam (dalam tahun)
- 'home_ownership' : status kepemilikan rumah peminjam
- 'annual_inc' : pendapatan tahunan peminjam
- 'verification_status' : status verifikasi pendapatan peminjam
- 'issue_d' : tanggal peminjaman dilakukan
- 'loan_status' : status pembayaran pinjaman (lunas atau masih dalam pembayaran)
- 'pymnt_plan' : apakah peminjam memiliki rencana pembayaran
- 'url' : halaman pinjaman di situs web
- 'desc' : deskripsi pinjaman
- 'purpose' : tujuan pinjaman
- 'title' : judul pinjaman
- 'zip_code' : kode pos peminjam
- 'addr_state' : alamat peminjam (negara bagian)
- 'dti' : rasio utang terhadap pendapatan peminjam
- 'delinq_2yrs' : jumlah keterlambatan pembayaran dalam 2 tahun terakhir
- 'earliest_cr_line' : tanggal terbentuknya kredit terlama peminjam
- 'inq_last_6mths' :  jumlah permintaan kredit dalam 6 bulan terakhir
- 'mths_since_last_delinq' : jumlah bulan sejak keterlambatan pembayaran terakhir
- 'mths_since_last_record' : jumlah bulan sejak catatan kredit terakhir
- 'open_acc' : jumlah rekening yang terbuka
- 'pub_rec' : jumlah catatan publik
- 'revol_bal' : saldo kredit yang harus dibayar oleh peminjam
- 'revol_util' : rasio penggunaan saldo kredit terhadap total kredit yang tersedia
- 'total_acc' : jumlah total akun kredit yang dimiliki oleh peminjam
- 'initial_list_status' : status listing pinjaman
- 'out_prncp' : jumlah pokok pinjaman yang belum dibayar
- 'out_prncp_inv' : jumlah pokok pinjaman yang belum dibayar setelah dikurangi biaya pengelolaan
- 'total_pymnt' : jumlah total pembayaran pinjaman
- 'total_pymnt_inv' : jumlah total pembayaran pinjaman setelah dikurangi biaya pengelolaan
- 'total_rec_prncp' :  jumlah total pembayaran pokok pinjaman
- 'total_rec_int' : jumlah total pembayaran
- 'total_rec_late_fee' : Jumlah denda yang dibebankan pada peminjam karena pembayaran keterlambatan
- 'recoveries' : Jumlah uang yang dikumpulkan oleh pemberi pinjaman sebagai hasil dari upaya pemulihan setelah pinjaman dianggap macet
- 'collection_recovery_fee' : Biaya yang dibebankan oleh pemberi pinjaman kepada peminjam untuk memulihkan dana yang belum terbayar setelah pemulihan
- 'last_pymnt_d' : Tanggal terakhir ketika peminjam melakukan pembayaran
- 'last_pymnt_amnt' : Jumlah pembayaran terakhir yang dilakukan oleh peminjam
- 'next_pymnt_d' : Tanggal jatuh tempo pembayaran berikutnya
- 'last_credit_pull_d' : Tanggal terakhir ketika pemberi pinjaman memeriksa riwayat kredit peminjam
- 'collections_12_mths_ex_med' : Jumlah koleksi yang dilakukan oleh kolektor dalam 12 bulan terakhir, tidak termasuk koleksi medis
- 'mths_since_last_major_derog' : Jumlah bulan sejak insiden kredit utama terakhir peminjam
- 'policy_code' : Kode produk yang diterapkan pada pinjaman
- 'application_type' : Tipe aplikasi yang diajukan oleh peminjam (perorangan atau bersama)
- 'annual_inc_joint' : Pendapatan tahunan bersih gabungan jika peminjam mengajukan pinjaman bersama dengan pemohon lain
- 'dti_joint' : Rasio utang terhadap pendapatan bersih gabungan jika peminjam mengajukan pinjaman bersama dengan pemohon lain
- 'verification_status_joint' : Status verifikasi jika peminjam mengajukan pinjaman bersama dengan pemohon lain
- 'acc_now_delinq' : Jumlah akun yang sedang menunggak pembayaran saat ini oleh peminjam
- 'tot_coll_amt' : Jumlah total akun yang dikumpulkan oleh kolektor
- 'tot_cur_bal' : Total saldo akun saat ini peminjam
-'open_acc_6m' : Jumlah akun baru yang dibuka dalam 6 bulan terakhir oleh peminjam
- 'open_il_6m' : Jumlah pinjaman baru yang dibuka dalam 6 bulan terakhir oleh peminjam
- 'open_il_12m' : Jumlah pinjaman baru yang dibuka dalam 12 bulan terakhir oleh peminjam
- 'open_il_24m' : Jumlah pinjaman baru yang dibuka dalam 24 bulan terakhir oleh peminjam
- 'mths_since_rcnt_il' : Jumlah bulan sejak pinjaman terbaru peminjam yang dijamin oleh properti
- 'total_bal_il' : Total saldo pinjaman yang dijamin oleh properti yang dimiliki oleh peminjam
- 'il_util' : Rasio utilitas pinjaman yang dijamin oleh properti yang dimiliki oleh peminjam
- 'open_rv_12m' : Jumlah rekening kartu kredit baru yang dibuka dalam 12 bulan terakhir oleh peminjam
- 'open_rv_24m' : Jumlah rekening kartu kredit baru yang dibuka dalam 24 bulan terakhir oleh peminjam
- 'max_bal_bc' : Saldo tertinggi pada rekening kartu kredit sirkuler oleh peminjam dalam 6 bulan terakhir
- 'all_util' : Rasio penggunaan total saldo
- 'total_rev_hi_lim' : Total saldo kredit bergulir/batas kredit
- 'inq_fi' : Jumlah permintaan informasi keuangan pribadi
- 'total_cu_tl' : Jumlah transaksi keuangan
- 'inq_last_12m' : Jumlah permintaan kredit dalam 12 bulan terakhir

### **Remove Columns that Inrelevant to Analysis**

Kolom yang berisi ID, Tanggal, maupun Code akan dihapus
"""

df = df.drop(columns = ['id', 'member_id', 'desc', 'policy_code', 'pymnt_plan',
                        'zip_code', 'emp_title', 'title', 'annual_inc_joint',
                        'dti_joint', 'verification_status_joint', 'url','issue_d',
                        'last_credit_pull_d', 'last_pymnt_d', 'earliest_cr_line'])

"""### **Remove Columns that Contains >40% Missing Value**"""

# Membuat data frame baru yang berisi nama kolom dan persentase kolom mengandung missing value

lst_missval = []

for i in df.isnull().sum():
  lst_missval.append((i / len(df) * 100))

df_missval = pd.DataFrame({'Column Name':df.columns,
                           'Missing Value Percentage (%)':np.round(lst_missval,2)})

df_missval = df_missval[df_missval['Missing Value Percentage (%)'] != 0]

df_missval = df_missval.sort_values(by='Missing Value Percentage (%)',
                       ascending = False).reset_index().drop(columns = 'index')

df_missval

# Menghapus kolom pada data yang memiliki missing value >40% berdasarkan data frame "df_missval"

df_missval_remove_cols = df_missval[df_missval['Missing Value Percentage (%)'] > 40 ][['Column Name']]
df = df.drop(columns = df_missval_remove_cols['Column Name'])

df

# Kolom yang akan dilakukan analisis

df.columns

"""**Output**

Dari hasil menghapus kolom yang tidak relevan dan memiliki missing value > 40%, maka data yang digunakan saat ini berjumlah 40 kolom dengan 466285 baris.

## **Handling Missing Value**
"""

lst_missval = []

for i in df.isnull().sum():
  lst_missval.append((i / len(df) * 100))

df_missval = pd.DataFrame({'Column Name':df.columns,
                           'Missing Value Percentage (%)':np.round(lst_missval,2),
                           'Data Types':df.dtypes})

df_missval = df_missval[df_missval['Missing Value Percentage (%)'] != 0]

df_missval = df_missval.sort_values(by='Missing Value Percentage (%)',
                       ascending = False).reset_index().drop(columns = 'index')

df_missval

"""
Dari tabel di atas, terdapat 11 kolom yang memiliki missing value < 40% dengan 2 jenis data yaitu numerik, maupun kategorik. Untuk penanganan kedua jenis data tersebut berbeda, jika

- Data numerik : akan dilakukan imputasi dengan nilai median karena median lebih tahan terhadap outlier
- Data kategorik : akan dilakukan imputasi dengan nilai modus"""

# Mengisi missing value berdasarkan tipe data
for col in df.columns:
    if df[col].dtype == 'object':  # Jika tipe data kategorik
        df[col] = df[col].fillna(df[col].mode()[0])
    else:  # Jika tipe data numerik
        df[col] = df[col].fillna(df[col].median())

# Cek missing value

print(df.isna().sum())

"""**Output**

Dari hasil imputasi, dapat dilihat pada output di atas bahwa data sudah tidak memiliki missing value

## **Data Type Checking**
"""

# Mengecek tipe data setiap kolom

df.dtypes

# Kolom-kolom yang bertipe data kategorik

object_columns = df.select_dtypes(include=['object'])
print("Columns with object data:\n", object_columns)

"""**Output**

Pada output di atas, terlihat bahwa kolom 'term' bertipe data kategorik yang seharusnya adalah numerik. Sehingga, perlu dilakukan pengubahan penghapusan kata "months" dan ubah menjadi numerik

### **Handling Numeric Columns**
"""

# Menghapus kata "months" dan mengubahnya menjadi numerik
df['term'] = df['term'].str.replace(' months', '').astype(int)

df

"""### **Handling Categoric Columns**"""

# Menampilkan kategori dan jumlah kemunculannya untuk setiap kolom kategorik
for col in object_columns.columns:
    print(f"Kategori untuk kolom '{col}':")
    print(df[col].value_counts())
    print()  # Tambahkan baris kosong untuk pemisah

"""**Output**

Pada kolom 'loan_status' terdapat 2 kategori yang duplikat yaitu 'Does not meet the credit policy. Status:Fully Paid' sama dengan 'Fully Paid' dan 'Does not meet the credit policy. Status:Charged Off' sama dengan 'Charged Off'

sehingga, kedua kategori akan disederhanakan
"""

# Menyederhanakan kategori
df['loan_status'] = df['loan_status'].replace({
    'Does not meet the credit policy. Status:Fully Paid': 'Fully Paid',
    'Does not meet the credit policy. Status:Charged Off': 'Charged Off'
})

# Menampilkan hasil
print(df['loan_status'].value_counts())

"""### **Grouping Target Variable**"""

# Mengelompokkan variabel target (loan_status) ke dalam 2 kategori (Good dan Bad)

# Membuat kolom baru 'loan_status_grouped' berdasarkan pengelompokan
def categorize_loan_status(status):
    if status in ['Fully Paid', 'Current', 'In Grace Period']:
        return 'Good'
    elif status in ['Charged Off', 'Default', 'Late (16-30 days)', 'Late (31-120 days)']:
        return 'Bad'

df['loan_status_grouped'] = df['loan_status'].apply(categorize_loan_status)

# Melihat hasil pengelompokan
print(df['loan_status_grouped'].value_counts())

"""# **Data Clean**

## **Gambaran Umum Dataset**
"""

df

"""**Interpretasi**

Data yang digunakan setelah proses preparation, terdapat 40 kolom dengan 30 di antaranya bertipe data numerik dan 10 kolom bertipe data kategorik dengan 466281 baris.

Karena target yang ditetapkan untuk memprediksi risiko kredit, maka variabel y yang akan dipilih adalah **loan_status**

## **Statistik Deskriptif**

### **Data Numerik**
"""

df.describe()

"""### **Data Kategorik**"""

# Menampilkan kategori dan jumlah kemunculannya untuk setiap kolom kategorik
for col in object_columns.columns:
    print(f"Kategori untuk kolom '{col}':")
    print(df[col].value_counts())
    print()  # Tambahkan baris kosong untuk pemisah

"""## **Visualisasi Data**

### **Bar Chart Variabel y (loan_status)**
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Countplot untuk distribusi loan_status
plt.figure(figsize=(10, 6))
sns.countplot(y='loan_status', data=df, order=df['loan_status'].value_counts().index, palette='viridis')
plt.title('Distribusi Loan Status')
plt.xlabel('Jumlah')
plt.ylabel('Loan Status')
plt.show()

"""### **Loan_status dengan Purpose**"""

# Crosstab untuk loan_status dan purpose
crosstab = pd.crosstab(df['purpose'], df['loan_status'])

# Membuat stacked bar chart
crosstab.plot(kind='bar', stacked=True, figsize=(14, 8), colormap='viridis')
plt.title('Distribusi Loan Status Berdasarkan Purpose')
plt.xlabel('Purpose')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.legend(title='Loan Status')
plt.show()

# Crosstab untuk loan_status dan purpose
crosstab = pd.crosstab(df['verification_status'], df['loan_status'])

# Membuat stacked bar chart
crosstab.plot(kind='bar', stacked=True, figsize=(14, 8), colormap='viridis')
plt.title('Distribusi Loan Status Berdasarkan Purpose')
plt.xlabel('Purpose')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.legend(title='Loan Status')
plt.show()

"""### **Heatmap**"""

# Menghitung korelasi antara kolom numerik
correlation_matrix = df.corr(numeric_only=True)

# Heatmap untuk korelasi
plt.figure(figsize=(20, 16))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Heatmap Korelasi')
plt.show()

"""# **Data Modelling**"""

from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.metrics import classification_report, roc_auc_score

"""## **Encoding**"""

from sklearn.preprocessing import LabelEncoder

# Buat instance dari LabelEncoder
le = LabelEncoder()

# Looping untuk melakukan encoding pada semua kolom yang bertipe data 'object'
for col in df.select_dtypes('object').columns:
  if col != 'loan_status_grouped':
    df[col] = le.fit_transform(df[col].astype(str))

df.head()

"""## **Split Data**"""

# Membagi data menjadi train-test

from sklearn.model_selection import train_test_split
X = df.drop(columns=['loan_status_grouped'])  # Fitur
y = df['loan_status_grouped']  # Target

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""## **Logistic Regression**"""

from sklearn.linear_model import LogisticRegression
logreg = LogisticRegression(max_iter=1000, random_state=42)
logreg.fit(X_train, y_train)

"""## **Random Forest**"""

from sklearn.ensemble import RandomForestClassifier
rforest = RandomForestClassifier(n_estimators=100, max_depth=10, random_state=42)
rforest.fit(X_train, y_train)

"""## **K-Nearest Neighbors (KNN)**"""

from sklearn.neighbors import KNeighborsClassifier
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train, y_train)

"""## **Naive Bayes**"""

from sklearn.naive_bayes import MultinomialNB
nb = MultinomialNB()
nb.fit(X_train, y_train)

"""# **Evaluation**"""

import pandas as pd
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Inisialisasi dictionary untuk menyimpan hasil evaluasi
results = {
    "Model": [],
    "Accuracy": [],
    "Precision": [],
    "Recall": [],
    "F1-Score": []
}

# Fungsi untuk mengevaluasi model
def evaluate_model(model, model_name, X_test, y_test):
    y_pred = model.predict(X_test)
    results["Model"].append(model_name)
    results["Accuracy"].append(accuracy_score(y_test, y_pred))
    results["Precision"].append(precision_score(y_test, y_pred, average='weighted'))
    results["Recall"].append(recall_score(y_test, y_pred, average='weighted'))
    results["F1-Score"].append(f1_score(y_test, y_pred, average='weighted'))

# Logistic Regression
evaluate_model(logreg, "Logistic Regression", X_test, y_test)

# Random Forest
evaluate_model(rforest, "Random Forest", X_test, y_test)

# KNN
evaluate_model(knn, "K-Nearest Neighbors", X_test, y_test)

# Naive Bayes
evaluate_model(nb, "Naive Bayes", X_test, y_test)

# Membuat hasil evaluasi menjadi dataframe
evaluation_df = pd.DataFrame(results)

# Menampilkan hasil evaluasi
print(evaluation_df)